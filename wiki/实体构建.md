## 实体构建

* 构建GenericValue
  ```java
  Delegator delegator = dctx.getDelegator();
  GenericValue userDemo = delegator.makeValue("UserDemo");
  ```

  * GenericDelegator.makeValue(String entityName)

    ```java
        public GenericValue makeValue(String entityName) {
            ModelEntity entity = this.getModelEntity(entityName);
            if (entity == null) {
                throw new IllegalArgumentException("[GenericDelegator.makeValue] could not find entity for entityName: " + entityName);
            }
            GenericValue value = GenericValue.create(entity);
            value.setDelegator(this);
            return value;
        }
    ```

    * GenericValue.create(ModelEntity modelEntity) 

      ```java
          public static GenericValue create(ModelEntity modelEntity) {
              GenericValue newValue = new GenericValue();
              newValue.init(modelEntity);
              return newValue;
          }
      ```

    * ~GenericValue.create

  * ~GenericDelegator.makeValue(String entityName)

* 构建完GenericValue后，设置它自身的一些属性

  ```java
  // 设置自增id
  userDemo.setNextSeqId();
  // 从context map中设置所有非主键值
  userDemo.setNonPKFields(context);
  // 在数据库中创建记录(insert)
  userDemo = delegator.create(userDemo);
  ```

## GenericValue

### create，新增实体

```java
/** Creates new GenericValue */
public static GenericValue create(ModelEntity modelEntity);

/** Creates new GenericValue from existing Map */
public static GenericValue create(Delegator delegator, ModelEntity modelEntity, Map<String, ? extends Object> fields);

/** Creates new GenericValue from existing Map */
public static GenericValue create(Delegator delegator, ModelEntity modelEntity, Object singlePkValue);
    
/** Creates new GenericValue from existing GenericValue */
public static GenericValue create(GenericValue value);

/** Creates new GenericValue from existing GenericValue */
public static GenericValue create(GenericPK primaryKey);

/** Creates new GenericValue from existing GenericValue */
public GenericValue create() throws GenericEntityException;

```

### store，写入实体

```java
/** store */
public void store() throws GenericEntityException {
    this.getDelegator().store(this);
}
```

### remove，删除实体

```java
/** remove */
public void remove() throws GenericEntityException {
    this.getDelegator().removeValue(this);
}
```

### getRelated，从DB获取相关实体

```java
public List<GenericValue> getRelated(String relationName, Map<String, ? extends Object> byAndFields, List<String> orderBy);

public List<GenericValue> getRelated(String relationName, Map<String, ? extends Object> byAndFields, List<String> orderBy, boolean useCache);

public List<GenericValue> getRelatedMulti(String relationNameOne, String relationNameTwo, List<String> orderBy)
```



## GenericEntity

### setNextSeqId，设置自增id

```java
    /**
     * Sets next seq id.
     */
    public void setNextSeqId() {
        List<String> pkFieldNameList = this.modelEntity.getPkFieldNames();
        if (pkFieldNameList.size() != 1) {
            throw new IllegalArgumentException("Cannot setNextSeqId for entity [" + this.getEntityName()
                    + "] that does not have a single primary key field, instead has [" + pkFieldNameList.size() + "]");
        }

        String pkFieldName = pkFieldNameList.get(0);
        //if (this.get(pkFieldName) != null) {
            // don't throw exception, too much of a pain and usually intended: throw new IllegalArgumentException("Cannot setNextSeqId, pk field ["
        // + pkFieldName + "] of entity [" + this.getEntityName() + "] already has a value [" + this.get(pkFieldName) + "]");
        //}

        String sequencedValue = this.getDelegator().getNextSeqId(this.getEntityName());
        this.set(pkFieldName, sequencedValue);
    }
```

### setNonPKFields，从context map中设置所有非主键值

```java
    /** go through the non-pks and for each one see if there is an entry in fields to set  @param fields the fields */
    public void setNonPKFields(Map<? extends Object, ? extends Object> fields) {
        setAllFields(fields, true, null, Boolean.FALSE);
    }

    /**
     * Intelligently sets fields on this entity from the Map of fields passed in
     * @param fields The fields Map to get the values from
     * @param setIfEmpty Used to specify whether empty/null values in the field Map should over-write non-empty values
     * in this entity
     * @param namePrefix If not null or empty will be pre-pended to each field name (upper-casing the first letter of
     * the field name first), and that will be used as the fields Map lookup name instead of the field-name
     * @param pks If null, get all values, if TRUE just get PKs, if FALSE just get non-PKs
     */
    public void setAllFields(Map<? extends Object, ? extends Object> fields, boolean setIfEmpty, String namePrefix, Boolean pks) {
        // fields，实体的键值对
        if (fields == null) {
            return;
        }
        Iterator<ModelField> iter = null;
        if (pks != null) {
            if (pks) {
                iter = this.getModelEntity().getPksIterator();
            } else {
                iter = this.getModelEntity().getNopksIterator();
            }
        } else {
            iter = this.getModelEntity().getFieldsIterator();
        }

        // 遍历指定的键值对
        while (iter != null && iter.hasNext()) {
            ModelField curField = iter.next();
            String fieldName = curField.getName();
            String sourceFieldName = null;
            if (UtilValidate.isNotEmpty(namePrefix)) {
                sourceFieldName = namePrefix + Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);
            } else {
                sourceFieldName = curField.getName();
            }

            if (fields.containsKey(sourceFieldName)) {
                Object field = fields.get(sourceFieldName);

                if (setIfEmpty) {
                    // if empty string, set to null
                    if (field != null && field instanceof String && ((String) field).isEmpty()) {
                        this.set(curField.getName(), null);
                    } else {
                        this.set(curField.getName(), field);
                    }
                } else {
                    // okay, only set if not empty...
                    if (field != null) {
                        // if it's a String then we need to check length, otherwise set it because it's not null
                        if (field instanceof String) {
                            String fieldStr = (String) field;

                            if (!fieldStr.isEmpty()) {
                                this.set(curField.getName(), fieldStr);
                            }
                        } else {
                            this.set(curField.getName(), field);
                        }
                    }
                }
            }
        }
    }
```

* GenericEntity.set(String name, Object value)

  ```java
      /** Sets the named field to the passed value, even if the value is null
       * @param name The field name to set
       * @param value The value to set
       */
      public void set(String name, Object value) {
          set(name, value, true);
      }
  ```

  * **set(String name, Object value, boolean setIfNull) ，生成实体中的属性及值**

    ```java
    /** Sets the named field to the passed value. If value is null, it is only
         *  set if the setIfNull parameter is true. This is useful because an update
         *  will only set values that are included in the HashMap and will store null
         *  values in the HashMap to the datastore. If a value is not in the HashMap,
         *  it will be left unmodified in the datastore.
         * @param name The field name to set
         * @param value The value to set
         * @param setIfNull Specifies whether or not to set the value if it is null
         */
        public Object set(String name, Object value, boolean setIfNull) {
            assertIsMutable();
            ModelField modelField = getModelEntity().getField(name);
            if (modelField == null) {
                throw new IllegalArgumentException("[GenericEntity.set] \"" + name + "\" is not a field of " + entityName + ", must be one of: "
                        + getModelEntity().fieldNameString());
            }
            if (value != null || setIfNull) {
                ModelFieldType type = null;
                try {
                    type = getDelegator().getEntityFieldType(getModelEntity(), modelField.getType());
                } catch (IllegalStateException | GenericEntityException e) {
                    Debug.logWarning(e, MODULE);
                }
                if (type == null) {
                    throw new IllegalArgumentException("Type " + modelField.getType() + " not found for entity [" + this.getEntityName()
                            + "]; probably because there is no datasource (helper) setup for the entity group that this entity is in: ["
                            + this.getDelegator().getEntityGroupName(this.getEntityName()) + "]");
                }
    
                if (value instanceof Boolean) {
                    // if this is a Boolean check to see if we should convert from an indicator or just leave as is
                    try {
                        int fieldType = SqlJdbcUtil.getType(type.getJavaType());
                        if (fieldType != 10) {
                            value = (Boolean) value ? "Y" : "N";
                        }
                    } catch (GenericNotImplementedException e) {
                        throw new IllegalArgumentException(e.getMessage());
                    }
                } else if (value != null && !(value instanceof NULL)) {
                    // make sure the type matches the field Java type
                    if (value instanceof String && "byte[]".equals(type.getJavaType())) {
                        value = ((String) value).getBytes(StandardCharsets.UTF_8);
                    } else if (!ObjectType.instanceOf(value, type.getJavaType())) {
                        try {
                            value = ObjectType.simpleTypeOrObjectConvert(value, type.getJavaType(), null, null);
                        } catch (GeneralException e) {
                            String errMsg = "In entity field [" + this.getEntityName() + "." + name + "] set the value passed in ["
                                    + value.getClass().getName() + "] is not compatible with the Java type of the field [" + type.getJavaType() + "]";
                            // eventually we should do this, but for now we'll do a "soft" failure: throw new IllegalArgumentException(errMsg);
                            Debug.logWarning(new Exception("Location of database type warning"),
                                    "=-=-=-=-=-=-=-=-= Database type warning GenericEntity.set =-=-=-=-=-=-=-=-= " + errMsg, MODULE);
                        }
                    }
                }
                Object old = fields.put(name, value);
    
                generateHashCode = true;
                this.setChanged();
                this.notifyObservers(name);
                return old;
            }
            return fields.get(name);
        }
    ```

    